<!DOCTYPE html>
<html>
	<head>
		<title>ShapeClip | Demo Page</title>
		
		<!-- Styling -->
		<link href='http://fonts.googleapis.com/css?family=Cabin:400,700' rel='stylesheet' type='text/css'>
		<style>
			document, body { background-color: black; color: white; } 
			.sc_pad {
				background-color: black;
			}
			
			#colourwheel { position: fixed; bottom: 5cm; right: 15cm; }
			#controls { position: fixed; bottom: 1cm; right: 1cm; }
			#sugar { pointer-events: none; z-index: -99; position: fixed; bottom: 1cm; right: 1cm; color: #111; font-size: 5cm; font-family: 'Cabin', sans-serif; text-shadow: 1px 1px #222, -1px -1px #111}
		</style>
		
		<!-- Import libraries -->
		<script type="text/javascript" src="js/oop.js"></script>
		<script type="text/javascript" src="js/Tween.js"></script>
		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="js/jquery-2.1.0.min.js"></script>
		
		<script type="text/javascript" src="js/raphael-min.js"></script>
		<script type="text/javascript" src="js/colorwheel.js"></script>
		
		
		
		<script type="text/javascript">
			
			// Define a pad.
			
			function grayscale(fPercentage) {
				var iHex = Number(parseInt((255 * fPercentage) , 10)).toString(16);
				return "#" + iHex + iHex + iHex;
			}
			
			
			/**
			 * @brief The Pad defines a place on a screen where a physical shape-changing actuator is placed.
			 * A 'settings' parameter (dictionary) is taken by the constructor.
			 * It contains a layer (pad.element()) which has the "sc_pad" classname.
			 */
			var Pad = Class.extend({
				
				/**
				 * @brief Construct this pad.
				 * @param settings The dictionary of arguments.
				 *      settings.width  	- The total width of the pad (mm).
				 *      settings.height 	- The total height of the pad (mm).
				 *      settings.x   		- The horizontal centre position of the pad from the top-left of the screen (mm).
				 *      settings.y   		- The vertical centre position of the pad from the top-left of the screen (mm).
				 *      settings.angle   	- The rotation applied to this pad in degrees.  0 degrees is the top of the screen.
				 *      settings.parent     - The parent element within which to add the pad.
				 */
				init: function(settings) {
					
					// Check the DOM is ready.
					if (document.readyState != "complete")
						throw "Page not ready.  Please only create pads when the page is ready.";
					
					// Check for required data.
					if (settings.width === undefined || settings.height === undefined)
						throw "Invalid size.  Specifiy width and height (mm).";
					if ((settings.x || 10.00) < 0 || (settings.y || 10.00) < 0)
						throw "Invalid position.  Specify positive numbers (mm).";
					
					// Get the parent element.
					var parent = settings.parent || document.body;
					
					// Create a new DOM element layer for this pad's graphics.
					this._element = document.createElement("div");
					this._element.classList.add("sc_pad");
					this._element.style.position = "fixed";
					this._element.style["transform-origin"] = "50% 50%";
					parent.appendChild(this._element);
					
					// Configure the pad dimensions.
					this.size(settings.width, settings.height);
					this.position(settings.x, settings.y);
					this.rotate((settings.angle || 0.00) % 360.00);
					this.outline(settings.outline || false);
					
					// Options.
					this.mouseRotate(true);
					//this.mouseMove(true);
				},
				
				/**
				 * @brief Delete this pad.
				 */
				remove : function() { 
					
					// Remove the element from the DOM.
					if (this._element)
						this._element.remove();
				},
				
				/**
				 * @brief Get the base DOM node which represents this pad.
				 * @return One DOM node (a 'div') which contains the pad graphics.
				 */
				element : function() {
					return this._element;
				},
				
				/**
				 * @brief Show or hide the dashed outline of this pad.
				 * that is useful for indicating where a shape-changing display should be placed.
				 */
				outline : function(show) {
					if (arguments.length == 1)
					{
						this._outline = show;
						this._element.style["box-sizing"] = "border-box";
						this._element.style["border"] = (show ? "1px dashed white" : "none");
						this._element.style["border-top"] = (show ? "1px dashed cyan" : "none");
						return this;
					}
					return this._outline;
				},
				
				/**
				 * @brief Get/Set the position of this pad (mm).
				 * @param x The x position on screen (mm) defined by centre point.
				 * @param y The y position on screen (mm) defined by centre point.
				 * @return The position structure { x : X, y : Y }, or if parameters are passed, the pad itself.
				 */
				position : function(x, y) {
					
					// If they are given, set width and height.
					if (arguments.length == 2)
					{
						// Update local vars.
						this._x = x;
						this._y = y;
						
						// Update the shape.
						this._element.style.left = (this._x - (this._width  * 0.5)) + "mm";
						this._element.style.top  = (this._y - (this._height * 0.5)) + "mm";
						
						// Return this pad.
						return this;
					}
					
					// Otherwise return the size.
					return { x : this._x, y : this._y };
				},
				
				/**
				 * @brief Get/Set the size of this pad (mm).
				 * @param w The total width on screen (mm) for this pad to take up.
				 * @param h The total height on screen (mm) for this pad to take up.
				 * @return The size structure { width : X, height : Y }, or if parameters are passed, the pad itself.
				 */
				size : function(w, h) {
					
					// If they are given, set width and height.
					if (arguments.length == 2)
					{
						// Update local vars.
						this._width  = w;
						this._height = h;
						
						// Update the shape.
						this._element.style.width  = this._width  + "mm";
						this._element.style.height = this._height + "mm";
						
						// Return this pad.
						return this;
					}
					
					// Otherwise return the size.
					return { width : this._width, height : this._height };
				},
				
				/**
				 * @brief Get/Set the rotation applied to this pad (mm).
				 * @param degrees The rotation applied to this pad in degrees.  0 degrees is the top of the screen.
				 * @return The angle of this pad, or if parameters are passed, the pad itself. 
				 */
				rotate : function(degrees) {
					
					// If data is given, set it.
					if (degrees !== undefined)
					{
						console.log("setting angle " + degrees);
						this._angle = degrees;
						this._element.style["-webkit-transform"] = "rotate("+this._angle+"deg)";
						this._element.style["MozTransform"] = "rotate("+this._angle+"deg)";
						this._element.style["transform"] = "rotate("+this._angle+"deg)";
						return this;
					}
					
					// Otherwise return the value.
					return this._angle;
				},
			
				
				mouseRotate : function(enabled) {
					// Scope.
					var that = this;
					
					// Add the scrolling event.
					this._element.onmousewheel = function(e) {
						var fAngle = e.wheelDelta < 0 ? -10 : 10;
						that.rotate((that.rotate() + fAngle) % 360);
					}
				},
				
				/*
				mouseMove : function(enabled) {
					
					// Scope and variables.
					var that = this;
					
					var iStartX; var iStartY;
				
					var jUp = function(e) {
						that._element.onmouseup = null;
						that._element.onmousedown = null;
						//that._element.onmousemove = null;
					};
					var jMove = function(e) {
						// TODO: Put into mm!!!
						that._element.style.left = (e.pageX - iStartX) + "px";
						that._element.style.top  = (e.pageY - iStartY) + "px";
					};
					var jDown = function(e) {
						iStartX = e.offsetX;
						iStartY = e.offsetY;
						that._element.onmouseup = jUp;
						that._element.onmousemove = jMove;
					};
					
					this._element.onmousedown = jDown;
				},
				*/
			
			});
			
			
			/**
			 * @brief The ShapeClipv1 is a Pad which can move the ShapeClip v1 up and down.
			 */
			var ShapeClipv1 = Pad.extend({
			
				// Signal Constants.
				HIGH_IDX 	: 0,		// The index into the _signals array for the HIGH pulse.  This should always be 255 at index 0.
				LOW_IDX  	: 1,		// The index into the _signals array for the LOW pulse.  This should always be 0 at index 1.
				RED_IDX  	: 2,		// The index into the _signals array for the RED pulse.  This should always be 0-255 at index 2.
				GREEN_IDX  	: 3,		// The index into the _signals array for the GREEN pulse.  This should always be 0-255 at index 3.
				BLUE_IDX  	: 4,		// The index into the _signals array for the BLUE pulse.  This should always be 0-255 at index 4.
				
				PULSE_WIDTH : 200,		// The time the LDR has to sample each item in _signals. 200ms * 5 (for 5 pulses) is 1 RGB frame per second.
				
				TRAVEL_HEIGHT : 48.0,	// The number of mm that this ShapeClip unit can travel in mm.  (60mm screw length - 12mm flange height)
				
				/**
				 * @brief Construct this ShapeClipv1.
				 * @param settings The dictionary of arguments.
				 *      settings.width  	- The total width of the pad (mm).
				 *      settings.height 	- The total height of the pad (mm).
				 *      settings.x   		- The horizontal centre position of the pad from the top-left of the screen (mm).
				 *      settings.y   		- The vertical centre position of the pad from the top-left of the screen (mm).
				 *      settings.angle   	- The rotation applied to this pad in degrees.  0 degrees is the top of the screen.
				 */
				init : function(settings) {
					
					// Create the underlying pad.
					this._super(settings);
					
					// Create an element for controlling LDR1
					this._ldr1Element = document.createElement("div");
					this._ldr1Element.classList.add("sc_control");
					this._ldr1Element.style.position = "absolute";
					this._ldr1Element.style.width  = "50%";
					this._ldr1Element.style.height = "100%";
					this._ldr1Element.style.top    = "0px";
					this._ldr1Element.style.left   = "0px";
					this._ldr1Element.style["background-color"] = "white";
					this._ldr1Element.style["pointer-events"] = "none";
					this._element.appendChild(this._ldr1Element);
					
					// Create an element for controlling LDR1
					this._ldr2Element = document.createElement("div");
					this._ldr2Element.classList.add("sc_control");
					this._ldr2Element.style.position = "absolute";
					this._ldr2Element.style.width  = "50%";
					this._ldr2Element.style.height = "100%";
					this._ldr2Element.style.top    = "0px";
					this._ldr2Element.style.left   = "50%";
					this._ldr2Element.style["background-color"] = "black";
					this._ldr2Element.style["pointer-events"] = "none";
					this._element.appendChild(this._ldr2Element);
					
					// LDR values.
					this._ldr1(0.0);
					this._ldr2(0.0);
					
					// RGB Signal Pattern.
					this._signals = [255, 0, 0, 0, 0];
					
					// Pulsing values.
					this._bStopPulse = false;
					this._pLDR1PulseTmr = null;
					this._jPulseStopped = null;
					
					// Begin pulsing.
					
				},
				
				/**
				 * @brief Delete this pad.
				 */
				remove : function() { 
					
					// Stop the timer.
					this.stopPulse(function(){
						this._super();
					});
					
					// Remove it from the DOM.
					this._super();
				},
				
				/**
				 * @brief Set/Get the value of LDR1 as a 0-1 percentage.
				 * @param percent The value this LDR should transmit as a 0-1 percentage.
				 * @return The percentage value of this LDR, or if parameters are passed, the pad itself. 
				 */
				_ldr1 : function(percent) {
					
					// If data is given, set it.
					if (percent !== undefined)
					{
						if (percent < 0) percent = 0;
						if (percent > 1) percent = 1;
						this._fLDR1 = (percent * 100.0);
						this._ldr1Element.style["background-color"] = "hsl(0,0%,"+this._fLDR1+"%)";
						return this;
					}
					
					// Otherwise return the value.
					return (this._fLDR1 * 0.01);
				},
				
				/**
				 * @brief Set/Get the value of LDR1 as a 0-255 value.
				 * @param percent The value this LDR should transmit as a 0-255 value.
				 * @return The byte value of this LDR, or if parameters are passed, the pad itself. 
				 */
				_ldr1b : function(byte) {
					if (byte !== undefined) { this._ldr1(byte / 255.0); return this; }
					return parseInt(this._ldr1() * 255);
				},
				
				/**
				 * @brief Set/Get the value of LDR2 as a 0-1 percentage.
				 * @param percent The value this LDR should transmit as a 0-1 percentage.
				 * @return The percentage value of this LDR, or if parameters are passed, the pad itself. 
				 */
				_ldr2 : function(percent) {
					// If data is given, set it.
					if (percent !== undefined)
					{
						if (percent < 0) percent = 0;
						if (percent > 1) percent = 1;					
						this._fLDR2 = (percent * 100.0);
						this._ldr2Element.style["background-color"] = "hsl(0,0%,"+this._fLDR2+"%)";
						return this;
					}
					
					// Otherwise return the value.
					return (this._fLDR2 * 0.01);
				},
				
				/**
				 * @brief Set/Get the value of LDR2 as a 0-255 value.
				 * @param percent The value this LDR should transmit as a 0-255 value.
				 * @return The byte value of this LDR, or if parameters are passed, the pad itself. 
				 */
				_ldr2b : function(byte) {
					if (byte !== undefined) { this._ldr2(byte / 255.0); return this; }
					return parseInt(this._ldr2() * 255);
				},
				
				/**
				 * @brief Set/Get the red channel.
				 * @param value The value in the red channel (0-255).  Optional, if missing the value is returned.
				 * @return The value in the red channel, or if parameters are passed, the pad itself.
				 */
				r : function(value) {
					if (value !== undefined) { this._signals[this.RED] = value; return this; }
					return parseInt(this._signals[this.RED]);
				},
				/**
				 * @brief Set/Get the red channel.
				 * @param value The value in the red channel (0-255).  Optional, if missing the value is returned.
				 * @return The value in the red channel, or if parameters are passed, the pad itself.
				 */
				g : function(value) {
					if (value !== undefined) { this._signals[this.GREEN] = value; return this; }
					return parseInt(this._signals[this.GREEN]);
				},
				/**
				 * @brief Set/Get the red channel.
				 * @param value The value in the red channel (0-255).  Optional, if missing the value is returned.
				 * @return The value in the red channel, or if parameters are passed, the pad itself.
				 */
				b : function(value) {
					if (value !== undefined) { this._signals[this.BLUE] = value; return this; }
					return parseInt(this._signals[this.BLUE]);
				},
				
				/**
				 * @brief Set/Get the colour of the shape-clip device on this pad.
				 * This will accept three parameters in order: r,g,b (0-255).
				 * It will also accept a hex string, list or dictionary in the format: "#RRGGBB" | "#RGB" | [r,g,b] | { r:X,g:Y,b:Z } | { R:X, G:Y, B:Z }
				 * @return The value of this colour as a hex string, or if parameters are passed, the colour itself.
				 */
				colour : function(value) {
					
					// Get the colour from different data types.
					if (value !== undefined)
					{
						this._signals[this.RED] = value;
						return this;
					}
					
					// If there is one argument, treat as array or dictionary.
					if (arguments.length == 1)
					{
						// The args we will interpret.
						var r = 0;
						var g = 0;
						var b = 0;
						
						// Convert hex into RGB. - http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
						function hexToRgb(hex) {
							var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
							hex = hex.replace(shorthandRegex, function(m, r, g, b) { return r + r + g + g + b + b; });
							var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
							return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
						}
						
						// Check for list or dictionaries and interpret results, allowing for: "#RRGGBB" | "#RGB" | [r,g,b] | { r:X,g:Y,b:Z } | { R:X, G:Y, B:Z }
						var kValue = arguments[0];
						if 		(typeof(kValue) === "string") { var colour = hexToRgb(kValue); r = colour.r; g = colour.g; b = colour.b; }
						else if (kValue[0]   !== undefined && kValue[1]   !== undefined && kValue[2]   !== undefined) { r = kValue[0];   g = kValue[1];   b = kValue[2]	   	}
						else if (kValue['r'] !== undefined && kValue['g'] !== undefined && kValue['b'] !== undefined) { r = kValue['r']; g = kValue['g']; b = kValue['b']	}
						else if (kValue['R'] !== undefined && kValue['G'] !== undefined && kValue['B'] !== undefined) { r = kValue['R']; g = kValue['G']; b = kValue['B']	}
						
						// Load them into the signals table.
						this._signals[RED]   = r;
						this._signals[GREEN] = g;
						this._signals[BLUE]  = b;
						
						// Return the pad.
						return this;
					}
					
					// If there are three arguments, treat them as RGB.
					if (arguments.length == 3)
					{
						// Treat as floats or ints.
						var bFloat = false;
						
						// Load them into the signals table.
						this._signals[RED]   = bFloat ? parseFloat(arguments[0]) : parseInt(arguments[0]);
						this._signals[GREEN] = bFloat ? parseFloat(arguments[1]) : parseInt(arguments[1]);
						this._signals[BLUE]  = bFloat ? parseFloat(arguments[2]) : parseInt(arguments[2]);
						
						// Return the pad.
						return this;
					}
					
					// Get the colour as hex.
					function componentToHex(c) { var hex = c.toString(16); return hex.length == 1 ? "0" + hex : hex; }
					return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
				},
				
				/**
				 * @brief Stop the pulsing by killing the signal.
				 * If the pad is pulsing, this will incur a delay while the last pulse completes.  The jStopped callback will be called when it is stopped.
				 * If the pad is not pulsing, this will call the jStopped callback immediately.
				 * @jStopped A function to call when the pulsing stops. Optional.
				 * @return This pad.
				 */
				stopPulse : function(jStopped) {
					
					// If we are not pulsing already, call immediately.
					if (this._pLDR1PulseTmr == null)
					{
						// Clear values.
						this._jPulseStopped = null;
						this._bStopPulse = true;
						
						// Raise the stopped callback.
						if (jStopped != null)
							jStopped(this);
					}
					else
					{
						// Set up the values for so we can stop at the end of the pulse.
						this._jPulseStopped = jStopped;
						this._bStopPulse = true;
					}
					
					// Return the pad.
					return this;
				},
				
				/**
				 * @brief Begin the pulsing on LDR1 which transmits colour.
				 */
				pulse : function() {
					
					// Prevent it from already pulsing.
					if (this._pLDR1PulseTmr != null)
						throw "Pad is already pulsing";
					
					// Stick some variables on the stack.
					var that 	= this;
					var signal 	= 0;
					
					//Profiling code.
					//var start = performance.now();
					//var last = start;
					//var id = this._id;
					
					// Enable LDR1 pulse.
					this._bStopPulse = false;
					
					// Define a loop function.
					var loop;
					loop = function() {
						
						// Profiling code.
						// Let's log the time to measure the drawing load error.
						//var curr = performance.now();
						//lines.push("" + id + ","+(curr-last)+","+(curr-start));
						//last = curr;
						
						// Update graphics (approx 4ms timer error "on my machine" TM)
						that._ldr1b( that._signals[signal] );
						
						// Increase signal and loop.
						signal = ( signal + 1 ) % that._signals.length;
						
						// If we have a stop signal AND the next pulse is the first one, don't do it.
						if (that._bStopPulse && signal != 0)
						{
							// Cleanup.
							var jCallback = that._jPulseStopped;
							that._jPulseStopped = null;
							clearTimeout(that._pLDR1PulseTmr);
							that._pLDR1PulseTmr = null;
							
							// Callback.
							if (jCallback != null)
								jCallback(that);
							
							return;
						}
						
						// Otherwise, set the next pulse.
						that._pLDR1PulseTmr = setTimeout(loop, that.PULSE_WIDTH);
						
					};
					loop();
					
					// Return this pad.
					return this;
				},
				
				/**
				 * @brief Set/Get the height value this pad should transmit as a percentage.
				 * @param value The height (as a 0-1 percentage) for the device. 0 is lowest. 1 is highest.
				 * @return The height value as a 0-1 percentage, or if parameters are passed, the pad itself.
				 */
				height : function(value) {
					if (value !== undefined) { this._ldr2(value); }
					return this._ldr2();
				},
				
				/**
				 * @brief Set/Get the height value this pad should transmit as mm.
				 * The precision of this value is probably not completely accurate.  Based on TRAVEL_HEIGHT constant.
				 * @param value The height (mm) for the device. 0 is lowest. TRAVEL_HEIGHT is highest.
				 * @return The height value (mm) between 0 and TRAVEL_HEIGHT, or if parameters are passed, the pad itself.
				 */
				heightmm : function(value) {
					if (value !== undefined) { this._ldr2(value / this.TRAVEL_HEIGHT) }
					return this._ldr2() * this.TRAVEL_HEIGHT;
				},
				
			});
			
			
			
			
			// show/hide/toggle -- NO because OFF drives the display too :)
			
			// force redraw -- http://www.webmasterworld.com/forum91/453.htm
			var i = 0;
			var b = false;
			var s;
			
			var p1, p2;
			
			var pads = [];
			var lines = [];
			function start() {
				
				/*
				for (var x = 0; x < 11; ++x)
				{
					for (var y = 0; y < 9; ++y)
					{
						var pX = 10 + (x * 25);
						var pY = 10 + (y * 25);
						var pad = new ShapeClipv1({x: pX, y: pY, width: 20, height: 20});
						pad._id = "" + x + "x" + y;
						pad.outline(true);
						pads.push(pad);
					}
				}
				*/
				
				/**/
				p1 = new ShapeClipv1({x: 100, y: 100, width: 20, height: 20});
				p1.outline(true);
				
				p2 = new ShapeClipv1({x: 300, y: 150, width: 20, height: 20});
				p2.outline(true);
				
				p2.pulse();
				
				// Configure the UI Slider.
				document.getElementById("motorSlider").onchange = function(e){
					p2.height(this.value * 0.01);
				};
				
				// Configure the colour wheel.
				var cw = Raphael.colorwheel($("#colourwheel")[0], 150);
				cw.onchange(function(colour){
					var r = parseInt(colour.r);
					var g = parseInt(colour.g);
					var b = parseInt(colour.b);
					console.log(r + " " + g + " " + b);
					p2._signals = [255, 0,  r, g, b ] 
				});
				
				
			};
			
			
		</script>
		
	</head>
	
	<body onload="start()">
		<div id="colourwheel"></div>
		<div id="controls">
			<button onclick="for (var i=0; i<pads.length;++i) pads[i].pulse();">Begin Experiment</button>
			<button onclick="for (var i=0; i<pads.length;++i) pads[i].stopPulse(); window.data =(lines.join('\n'));">Store Data</button>
			<input id="motorSlider" type="range" min="0" max="100" />
		</div>
		<div id="sugar"><span>ShapeClip</span><span>v1</span></div>
	</body>
	
</html>